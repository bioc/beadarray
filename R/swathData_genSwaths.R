genSwaths <- function(txt, sectionName, twocolour = TRUE, GrnTiffSuffix2 = "-Swath2_Grn.tif", RedTiffSuffix2 = "-Swath2_Red.tif", section_height = 326, section_width = 397, swath_overlap = 81, locslist, verbose = TRUE) {
    
    ## Function to identify beads in the overlapping region between swaths
    ## For these beads intensities are calculated from both images for comparison
    ##
    ## Arguments:   txt - 5 column matrix generated by assignToImage()
    ##              sectionName - string containing name of section to read
    ##
    ## Output: list containing two 4-column matrices in the same format as bead-level txt files

    
    if(twocolour){
        if(length(locslist) !=4 ){stop("Number of locs files does not match number of colours")}
    }
    else {
        if(length(locslist) != 2){stop("Number of locs files does not match number of colours")}
    }
      
    glocs1<-locslist$glocs1
    glocs2<-locslist$glocs2
    rlocs2 <- NULL
   
    locsg <- rbind(locslist$glocs1,locslist$glocs2)
    if(twocolour){
        rlocs1<-locslist$rlocs1
        rlocs2<-locslist$rlocs2
        locsr <- rbind(locslist$rlocs1,locslist$rlocs2)
    }

    ## for now, assume any bead in the overlap that was decoded is in Swath1
    swath1 <- txt[which(txt[,ncol(txt)] == 1),]
    swath2 <- txt[which(txt[,ncol(txt)] == 2),]
    
    ## only continue if we can find the TIFF files
    if(file.exists(paste(sectionName, GrnTiffSuffix2, sep = ""))) {

        ## find the decoded beads in swath 1 locs file and get their IDs (this is really slow)
        if(verbose) cat("Identifying decoded beads... ")
        locsInTxt1 <- match(paste(glocs1[,1], glocs1[,2]), paste(swath1[,3], swath1[,4]));
        locsIDs1 <- swath1[locsInTxt1,1];
        locsIns1 <- swath1[locsInTxt1,2];
        locsInTxt2 <- match(paste(glocs2[,1], glocs2[,2]), paste(swath2[,3], swath2[,4]));
        locsIDs2 <- swath2[locsInTxt2,1];   
        locsIns2 <- swath2[locsInTxt2,2];
        if(verbose) cat("Done\n");
        
        if(verbose) cat("Creating locs grid... ")
        grid <- t(sapply(1:nrow(glocs1), beadarray:::locsIndicesToGrid, nrow = section_height, ncol = (section_width+swath_overlap)/2))
        if(verbose) cat("Done\n");
        
        ## indices for beads in the overlapping region (hardcoded at the moment)
        ## Swath1
        s1idx <- which(grid[,1] > ((section_width + swath_overlap)/2 - swath_overlap))
        ## Swath2 
        s2idx <- which(grid[,1] < swath_overlap+1)
        
        if(length(s1idx) != length(s2idx)) stop("Something is wrong!!!!");
        
        ## create matrix with two sets of coordinates and probeIDs in the middle
    
        overlap <- cbind(locsIDs1[s1idx],locsIns2[s2idx],glocs2[s2idx,],locsIns2[s2idx],rlocs2[s2idx,]);
    # colnames(overlap) <- c("swath1.X", "swath1.Y", "ProbeID", "swath2.X", "swath2.Y")
        ## remove non-decoded beads
        s1idx<-s1idx[-which(is.na(overlap[,1]))]
        s2idx<-s2idx[-which(is.na(overlap[,1]))]
        overlap <- overlap[-which(is.na(overlap[,1])),]
        
        ## now we need to compute intensities for both swaths 
        ## (maybe we should keep the .txt ones too, but we'll need to keep track of them,
        ##    which we don't do currently)
        
        tiff <- readTIFF(paste(sectionName, GrnTiffSuffix2, sep = ""));
        Gbg <- illuminaBackground(tiff, overlap[,3:4]);
        tiff <- illuminaSharpen(tiff);
        Gfg <- illuminaForeground(tiff, overlap[,3:4]);
        
        overlap[,2]<-floor(Gfg-Gbg)
    
        if(any(is.na(overlap[,2]))){
            s1idx<-s1idx[-which(is.na(overlap[,2]))]
            s2idx<-s2idx[-which(is.na(overlap[,2]))]
            overlap <- overlap[-which(is.na(overlap[,2])),]
        }
        
        if(twocolour) {
            tiff <- readTIFF(paste(sectionName, RedTiffSuffix2, sep = ""));
            Rbg <- illuminaBackground(tiff, overlap[,6:7]);
            tiff <- illuminaSharpen(tiff);
            Rfg <- illuminaForeground(tiff, overlap[,6:7]);

            overlap[,5]<-floor(Rfg-Rbg)

            if(any(is.na(overlap[,5]))) {    
                s1idx<-s1idx[-which(is.na(overlap[,5]))]
                s2idx<-s2idx[-which(is.na(overlap[,5]))]
                overlap <- overlap[-which(is.na(overlap[,5])),]
            }
        }
        else {
            overlap <- overlap[,-5];
        }
    
        overlap<-cbind(overlap,rep(2,dim(overlap)[1]))
        #colnames(overlap) <- colnames(swath2)

        overlap<-cbind(overlap,(1:(dim(overlap)[1])))
        swath2<-cbind(swath2,rep(0,dim(swath2)[1]))

        swath2<-rbind(swath2,overlap)
        colnames(swath2)[ncol(swath2)]<-"Overlap"

        swath1<-cbind(swath1,rep(0,dim(swath1)[1]))
        colnames(swath1)[ncol(swath1)]<-"Overlap"

        swath1[locsInTxt1[s1idx],dim(swath1)[2]]<-(1:(dim(overlap)[1]))
    }
    else {
        ## if we cant find the TIFFs then add a column to the swath data indicating there are no overlapping beads
        swath1 <- cbind(swath1, rep(0, nrow(swath1)));
        colnames(swath1)[ncol(swath1)] <- "Overlap";
        swath2 <- cbind(swath2, rep(0, nrow(swath2)));
        colnames(swath2)[ncol(swath2)] <- "Overlap";
    }
    ## return a list containing the two swaths (Removing the "Swath Index" column since that's implied)
    return(list("Swath1" = swath1[,-(ncol(swath1)-1)], "Swath2" = swath2[,-(ncol(swath2)-1)]));
}
    
    
