assignToImage <- function(txt, sectionName, inputDir = NULL, twocolour = TRUE, locslist, GrnTiffSuffix1 = "-Swath1_Grn.tif", GrnTiffSuffix2 = "-Swath2_Grn.tif", verbose = FALSE) {
    
    ## Function to determine which swath each bead in the .txt came from
    ##
    ## Arguments:  txt - 4 or 7 column matrix generated by reading bead-level text file
    ##             sectionName - string containing name of section to read
    ##             twocolour - is this a two colour array or not
    ##             locslist - list of locs files associated with the array
    ##             GrnTiffSuffix1 - suffix of tif file from green swath 1 
    ##             GrnTiffSuffix2 - suffix of tif file from green swath 2 
    ##             verbose - how much should be reported to the user?
    ##
    ## Output: 5 or 8column matrix identical to input but with an additional  
    ##         column defining which swath the bead came from
    

    ## First check that the stated number of channels is consistent with the locs list
    if(twocolour){
        if(length(locslist) != 4){stop("Number of locs files does not match number of colours")}
    }
    if(!twocolour){
        if(length(locslist) != 2){stop("Number of locs files does not match number of colours")}
    }

    if(verbose) cat("locs file list checks out\n")

    ## combine the txt and locs files using BeadDataPackR
        
    locsg <- rbind(locslist$glocs1,locslist$glocs2)
    if(twocolour){
        locsr <- rbind(locslist$rlocs1,locslist$rlocs2)
    }

    if(verbose) cat("Combining files... ")
    if(twocolour){tmp <- BeadDataPackR:::combineFiles(txt, locsGrn = locsg, locsRed = locsr)}
    if(!twocolour){tmp <- BeadDataPackR:::combineFiles(txt, locsGrn = locsg)}

    if(verbose) cat("Done\n")
    tmp[,"LocsIdx"] <- ifelse(tmp[,"LocsIdx"] <= nrow(locslist$glocs1), 1, 2)
    colnames(tmp)[colnames(tmp)=="LocsIdx"] <- "SwathIdx";

    ## remove non-decoded beads
    tmp <- tmp[-which(tmp[,"Code"] == 0),]

    ## if the result is smaller than the original .txt we must have some duplicates.
    ## find which they are and try using intensities to determine which image they're from
    unassigned <- NULL;
    if( nrow(tmp) < nrow(txt) ) {

        if(verbose) cat("Matching duplicate spots... ")

        ## if the tiff files exist we can calculate intesities from both images and compare to the txt file
        tiffFile1 <- file.path(inputDir, paste(sectionName, "-Swath1_Grn.tif", sep = ""))
        tiffFile2 <- file.path(inputDir, paste(sectionName, "-Swath2_Grn.tif", sep = ""))
        if( file.exists(tiffFile1) & file.exists(tiffFile2) ) {

            roundedX <- .Call("roundLocsFileValues", tmp[,3], PACKAGE = "BeadDataPackR");
            roundedY <- .Call("roundLocsFileValues", tmp[,4], PACKAGE = "BeadDataPackR");
            txtDups <- which(!paste(txt[,3], txt[,4]) %in% paste(roundedX, roundedY));
            ## create a data.frame for these unassigned beads
            unassigned <- cbind(txt[txtDups,], vector(length = length(txtDups)))
            for(i in 1:length(txtDups)) {
                g1 <- singleBeadIntensity(tiffFile1, txt[txtDups[i],3:4])
                g2 <- singleBeadIntensity(tiffFile2, txt[txtDups[i],3:4])
                ## assign the bead to the image which gives the closest intensity
                unassigned[i,ncol(unassigned)] <- which.min( abs( diff( c(txt[txtDups[i],2], g1, g2) ) ) )
            }
            message("Done");
        }
        else {
            message("Unable to find TIFF images; ", nrow(txt) - nrow(tmp), " beads cannot be assigned to a swath and will be ignored");
        }
    }
            
    tmp <- rbind(tmp, unassigned)
    ## reorder by probeID
    tmp <- tmp[order(tmp[,"Code"]),]
    return(tmp)

}
