assignToImage <- function(txt, sectionName, twocolour = TRUE, locslist, GrnTiffSuffix1 = "-Swath1_Grn.tif", GrnTiffSuffix2 = "-Swath2_Grn.tif", verbose = TRUE) {
    
    ## Function to determine which swath each bead in the .txt came from
    ##
    ## Arguments:  txt - 4 or 7 column matrix generated by reading bead-level text file
    ##             sectionName - string containing name of section to read
    ##             twocolour - is this a two colour array or not
    ##             locslist - list of locs files associated with the array
    ##             GrnTiffSuffix1 - suffix of tif file from green swath 1 
    ##             GrnTiffSuffix2 - suffix of tif file from green swath 2 
    ##             verbose - how much should be reported to the user?
    ##
    ## Output: 5 or 8column matrix identical to input but with an additional  
    ##         column defining which swath the bead came from
    

    ## First check that the stated number of channels is consistent with the locs list
    if(twocolour){
        if(length(locslist) != 4){stop("Number of locs files does not match number of colours")}
    }
    if(!twocolour){
        if(length(locslist) != 2){stop("Number of locs files does not match number of colours")}
    }

    if(verbose) cat("locs file list checks out\n")

    ## combine the txt and locs files using BeadDataPackR
        
    locsg <- rbind(locslist$glocs1,locslist$glocs2)
    if(twocolour){
        locsr <- rbind(locslist$rlocs1,locslist$rlocs2)
    }

    if(verbose) cat("Combining files... ")
    if(twocolour){tmp <- BeadDataPackR:::combineFiles(txt, locsGrn = locsg, locsRed = locsr)}
    if(!twocolour){tmp <- BeadDataPackR:::combineFiles(txt, locsGrn = locsg)}

    if(verbose) cat("Done\n")
    tmp[,"LocsIdx"] <- ifelse(tmp[,"LocsIdx"] <= nrow(locslist$glocs1), 1, 2)
    colnames(tmp)[colnames(tmp)=="LocsIdx"] <- "SwathIdx";

    ## remove non-decoded beads
    tmp <- tmp[-which(tmp[,"Code"] == 0),]

    ## if the result is smaller than the original .txt we must have some duplicates.
    ## find which they are and try using intensities to determine which image they're from
    unassigned <- NULL;
    if(nrow(tmp) < nrow(txt)) {
        if(verbose) cat("Matching duplicate spots... ")
        roundedX <- .Call("roundLocsFileValues", tmp[,3], PACKAGE = "BeadDataPackR");
        roundedY <- .Call("roundLocsFileValues", tmp[,4], PACKAGE = "BeadDataPackR");
        txtDups <- which(!paste(txt[,3], txt[,4]) %in% paste(roundedX, roundedY));
        ## create a data.frame for these unassigned beads
        unassigned <- cbind(txt[txtDups,], vector(length = length(txtDups)))
        for(i in 1:length(txtDups)) {
            tiffFile1 <- paste(sectionName, "-Swath1_Grn.tif", sep = "")
            g1 <- singleBeadIntensity(tiffFile1, txt[txtDups[i],3:4])
            tiffFile2 <- paste(sectionName, "-Swath2_Grn.tif", sep = "")
            g2 <- singleBeadIntensity(tiffFile2, txt[txtDups[i],3:4])
            ## assign the bead to the image which gives the closest intensity
            
            unassigned[i,dim(unassigned)[2]] <- which.min( abs( diff( c(txt[txtDups[i],2], g1, g2) ) ) )
        }
        cat("Done\n")
    }
            
    tmp <- rbind(tmp, unassigned)
    ## reorder by probeID
    tmp <- tmp[order(tmp[,"Code"]),]
    return(tmp)

}
