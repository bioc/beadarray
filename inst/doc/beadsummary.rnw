%\VignetteIndexEntry{Analysis of Bead-summary Data using beadarray} 
%\VignetteKeywords{beadarray expression analysis} 
%\VignettePackage{beadarray} 
\documentclass{article}

\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm 
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textsf{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

%%Setting eval=FALSE until beadarrayExampleData becomes available
\SweaveOpts{eval=TRUE, keep.source=FALSE}



\begin{document}
\title{Analysis of Bead-summary Data using beadarray}
\author{Mark Dunning}
\maketitle

\section*{Introduction}
\Rpackage{beadarray} is a package for the pre-processing and analysis of Illumina BeadArray. The main advantage is being able to read raw data output by Illumina's scanning software. Data presented in this form are in the same format regardless of the assay (i.e expression, genotyping, methylation) being performed. Thus, beadarray is able to handle all these types of data. Many functions within beadarray have been written to cope with this flexibility. 

The BeadArray technology involves randomly arranged arrays of beads, with beads having the same probe sequence attached colloquially known as a bead-type. BeadArrays are combined in parallel on either a rectangular chip (BeadChip) or a matrix of 8 by 12 hexagonal arrays (Sentrix Array Matrix or SAM). The BeadChip is further divided into strips on the surface known as sections, with each section giving rise to a different image when scanned by BeadScan. These images, and associated text files, comprise the raw data for a beadarray analysis. However, for BeadChips, the number of sections assigned to each biological sample may vary from 1 on HumanHT12 chips, 2 on HumanWG6 chips or sometimes ten or more for SNP chips with large numbers of SNPs being investigated. 

This vignette demonstrates the analysis of bead summary data using beadarray. The recommeded approach to obtain these data is to start with bead-level data and follow the steps illustrated in the vignette {\tt beadlevel.pdf} distributed with \Rpackage{beadarray}. If bead-level data are not available, the output of Illumina\'s BeadStudio or GenomeStudio can be read by \Rpackage{beadarray}. Example code to do this is provided at the end of this vignette. However, the same object types are produced from either of these routes and the same functionality is available.

To make the most use of the code in this vignette, you will need to install the \Rpackage{beadarrayExampleData} and \Rpackage{illuminaHumanv3.db} packages from {\tt Bioconductor}. 

<<installExampleData, echo=TRUE,eval=FALSE>>=
source("http://www.bioconductor.org/biocLite.R")
biocLite(c("beadarrayExampleData", "illuminaHumanv3.db"))

@

The data used are a summarized version of the bead-level data presented in the \Rpackage{BeadArrayUseCases} package. The code used to produce these data is given in the vignette of \Rpackage{beadarrayExampleData}, which follow similar steps to those described in the {\tt beadlevel.pdf} vignette of \Rpackage{beadarray}. The following commands give a basic description of the data.

<<prelim, echo=TRUE>>=
library("beadarray")

require(beadarrayExampleData)

data(exampleSummaryData)

exampleSummaryData


@



Summarized data are stored in an object of type \Rclass{ExpressionSetIllumina} which
is an extension of the \Rclass{ExpressionSet} class developed by the Bioconductor team as a container for data from high-throughput assays.\\


<<objectPeek, echo=TRUE>>=

exprs(exampleSummaryData)[1:5,1:5]
se.exprs(exampleSummaryData)[1:5,1:5]


@

Objects of this type use a series of slots to store the data.  For consistency with the definition of other \Rclass{ExpressionSet} objects, we refer to the expression values as the \Robject{exprs} matrix (this stores the probe-specific average intensities) which can be accessed using \Rfunction{exprs} and subset in the usual manner.
The \Robject{se.exprs} matrix, which stores the probe-specific variability can be accessed using \Rfunction{se.exprs}. 



\section*{feature and pheno data}

The \Rfunction{fData} and \Rfunction{pData} functions are useful shortcuts to find more information about the features (rows) and samples (columns) in the sumamry object. These annotations are created automatically whenever a bead-level data is summarized (see {\tt beadlevel.pdf}) or read from a BeadStudio file. The \Rfunction{fData} will be added to later, but initially contains information on whether each probe is a control or not.

<<annotations>>=

head(fData(exampleSummaryData))
table(fData(exampleSummaryData)[,"Status"])

pData(exampleSummaryData)

@

\section*{Subsetting the data}

There are various way to subset an \Rclass{ExpressionSetIllumina} object...


Subset by channel


<<subsetting1>>=

channelNames(exampleSummaryData)

exampleSummaryData.log2 <- channel(exampleSummaryData, "G")


@

Subset by column
<<subsetting2>>=


exampleSummaryData[,1:4]

@

Subset by row

<<subsetting3>>=

exampleSummaryData[1:10,]

@

Subset by row name
<<subsetting4>>=


randIDs <- sample(featureNames(exampleSummaryData), 1000)

exampleSummaryData[randIDs,]

@

\section*{Exploratory analysis using boxplots}


Boxplots of intensity levels and the number of beads are useful for quality assessment purposes. \Rpackage{beadarray} uses the \Rpackage{ggplot2} library to generate boxplots in the traditonal manner. The boxplot function can take any valid \Rclass{ExpressionSetIllumina} object and for these examples we plot just a subset of the original \Robject{exampleSummaryData} object using random row IDs.


<<boxplot1, fig=TRUE, echo=TRUE,width=8, height=4>>=

boxplot(exampleSummaryData.log2[randIDs,])

@

<<boxplot2, fig=TRUE, echo=TRUE,width=8, height=4>>=

boxplot(exampleSummaryData.log2[randIDs,], what="nObservations")

@



<<boxplot4, fig=TRUE, echo=TRUE,width=8, height=4>>=

boxplot(exampleSummaryData.log2[randIDs,], sampleFactor="SampleFac")

@

<<boxplot5, fig=TRUE, echo=TRUE,width=8, height=4>>=

boxplot(exampleSummaryData.log2[randIDs,], sampleFactor="SampleFac", probeFactor = "Status")

@


\subsection*{Adding extra probe annotation}

Extra feature annotation is available from annotation packages in Bioconductor. 

<<addFdata>>=
exampleSummaryData.log2 <- addFeatureData(exampleSummaryData.log2)
@

If we suspect that a particular gene may be differentially expressed between conditions, we can subset the \Rclass{ExpressionSetIllumina} object to just include probes that target the gene, and plot the response of these probes against the sample groups. Furthermore, the different probes can be distinguished using the \Rfunarg{probeFactor} parameter.

<<boxplot6, fig=TRUE, echo=TRUE,width=8, height=4>>=
ids <- which(fData(exampleSummaryData.log2)[,"SYMBOL"] == "ALB")

boxplot(exampleSummaryData.log2[ids,], sampleFactor = "SampleFac", probeFactor = "IlluminaID")
@

\section*{Other exploratory analysis}

Replicate observations can also be compared using the \Rfunction{plotMAXY}

<<MAs, fig=TRUE, echo=TRUE,width=8, height=6>>=
plotMAXY(exprs(exampleSummaryData), arrays=1:3,pch=16,log=FALSE)
@


In the top right corner we see the MA plots for all pairwise comparisons involving the 3 arrays. On
an MA plot, for each probe we plot the average of the log2 -intensities from the two arrays on the x-axis
and the difference in intensities (log2 -ratios) on the y-axis. For replicate arrays we would expect all
probes to be unchanged between the two samples and hence most points on the plot should lie along
the line y=0. In the lower left corner of the MAXY plot we see the XY plot and for replicate arrays we
would expect to see most points along the diagonal y = x. From this MAXY plot it is obvious that the
second array is systematically different to the other replicates and may benefit from normalisation.
Both XY and MA plots are available separately for a particular comparison of arrays using plotXY
and plotMA.\\

\section*{Normalisation}

To correct for differences in expression level across a chip and between chips we need to normalise
the signal to make the arrays comparable. The normalisation methods available in the affy package, or
variance-stabilising transformation from the lumi package may be applied using the normaliseIllumina
function. Below we quantile normalise the log2 transformed data.

<<normalise1>>=

exampleSummaryData.norm <- normaliseIllumina(exampleSummaryData.log2, method="quantile", transform="none")

@


<<normalise2>>=

exampleSummaryData.norm2 <- normaliseIllumina(channel(exampleSummaryData, "G.ul"), method="neqc", transform="none")

@



\section*{Filtering}


Filtering non-responding probes from further analysis can improve the power to detect differential expression. One way of achieving this is to remove probes whose probe sequence has undesirable properties. Annotation quality information is available from the platform specific annotation packages, such as \Rpackage{illuminaHumanv3.db}

Four basic annotation quality categories (`Perfect', `Good', `Bad' and `No match') are defined and have been shown to correlate with expression level and measures of differential expression.
We recommend removing probes assigned a `Bad' or `No match' quality score after normalization.
This approach is similar to the common practice of removing lowly-expressed probes, but with the additional benefit of discarding probes with a high expression level caused by non-specific hybridization.

<<filter, echo=TRUE, fig=TRUE>>=

library(illuminaHumanv3.db)

ids <- as.character(featureNames(exampleSummaryData.norm))

qual <- unlist(mget(ids, illuminaHumanv3PROBEQUALITY, ifnotfound=NA))

table(qual)

rem <- qual == "No match" | qual == "Bad" | is.na(qual)

exampleSummaryData.filt <- exampleSummaryData.norm[!rem,]

dim(exampleSummaryData.filt)

boxplot(exampleSummaryData.norm, probeFactor = "PROBEQUALITY", sampleFactor="SampleFac")

@

\section*{Differential expression}

The differential expression methods available in the limma package can be used to identify differentially
expressed genes. The functions lmFit and eBayes can be applied to the normalised data.
In the example below, we set up a design matrix for the example experiment and fit a linear model
to summarise the data from the UHRR and Brain replicates to give one value per condition. We then
define contrasts comparing the Brain sample to the UHRR and calculate moderated t-statistics with
empirical Bayes shrinkage of the sample variances. In this particular experiment, the Brain and UHRR
samples are very different and we would expect to see many differentially expressed genes.\\

Empirical array quality weights can be used to measure the relative reliability of each array.  A variance is estimated for each array by the \Rfunction{arrayWeights} function which measures how well the expression values from each array follow the linear model.
These variances are converted to relative weights which can then be used in the linear model to
down-weight observations from less reliable arrays which improves power to detect differential
expression.

We then define a contrast comparing UHRR to Brain Reference and calculate moderated $t$-statistics with empirical Bayes' shrinkage of the sample variances.

<<deanalysis>>=
library(limma)

rna <- factor(pData(exampleSummaryData)[,"SampleFac"])

design <- model.matrix(~0+rna)
colnames(design) <- levels(rna)
aw <- arrayWeights(exprs(exampleSummaryData.filt), design)
aw
fit <- lmFit(exprs(exampleSummaryData.filt), design, weights=aw)
contrasts <- makeContrasts(UHRR-Brain, levels=design)
contr.fit <- eBayes(contrasts.fit(fit, contrasts))
topTable(contr.fit, coef=1)

@

\section*{Annotation of results}

The \Rfunction{topTable} function displays the results of the empirical Bayes analysis alongside the annotation assigned by Illumina to each probe in the linear model fit. Often this will not provide sufficient information to infer biological meaning from the results. Within Bioconductor, annotation packages are available for each of the major Illumina expression array platforms that map the probe sequences designed by Illumina to functional information useful for downstream analysis. As before, the \Rpackage{illuminaHumanv3.db} package can be used for the arrays in this example dataset. 

<<annotation, echo=TRUE>>=

ids2 <- featureNames(exampleSummaryData.filt)

chr <- mget(ids2, illuminaHumanv3CHR, ifnotfound = NA)
cytoband<- mget(ids2, illuminaHumanv3MAP, ifnotfound = NA)
refseq <- mget(ids2, illuminaHumanv3REFSEQ, ifnotfound = NA)
entrezid <- mget(ids2, illuminaHumanv3ENTREZID, ifnotfound = NA)
symbol <- mget(ids2, illuminaHumanv3SYMBOL, ifnotfound = NA)
genename <- mget(ids2, illuminaHumanv3GENENAME, ifnotfound = NA)

anno <- data.frame(Ill_ID = ids2, Chr = as.character(chr),
           Cytoband = as.character(cytoband), RefSeq = as.character(refseq),
           EntrezID = as.numeric(entrezid), Symbol = as.character(symbol),
           Name = as.character(genename))

contr.fit$genes <- anno
topTable(contr.fit)

@


\section*{Reading bead summary data into beadarray}
BeadStudio/GenomeStudio is Illumina's proprietary software for analyzing data output by
the scanning system (BeadScan/iScan).  It contains different modules for analyzing data from different platforms.  For further information on the software and how to export summarized data, refer to the user's manual.  In this section we consider how to read in and analyze output from the gene expression module of BeadStudio/GenomeStudio.\\


The example dataset used in this section consists of an experiment with one Human
WG-6 version 2 BeadChip.  These arrays were hybridized with the control RNA samples used in the MAQC project (3 replicates of UHRR and 3 replicates of Brain Reference RNA).


The non-normalized data for regular and control probes was output by BeadStudio/GenomeStudio.


The example BeadStudio output used in this section is available in the file \newline{\tt AsuragenMAQC\_BeadStudioOutput.zip}
which can be downloaded from {\\tt http://www.switchtoi.com/datasets.ilmn}.

You will need to download and unzip the contents of this file to the current  {\tt R} working directory.
Inside this zip file you will find several files including summarized, non-normalized data
and a file containing control information.  
We give a more detailed description of each of the particular files we will make use of below.

\begin{itemize}
\item{Sample probe profile ({\tt AsuragenMAQC-probe-raw.txt}) ({\it required}) -
text file which contains the non-normalized summary values as output by BeadStudio.
Inside the file is a data matrix with some 48,000 rows.
In newer versions of the software, these data are preceded by several lines of header information.
Each row is a different probe in the experiment and the columns
give different measurements for the gene. For each array, we record the summarized
expression level (AVG\_Signal), standard error of the bead replicates (BEAD\_STDERR),
number of beads (Avg\_NBEADS) and a detection $p$-value (Detection Pval) which
estimates the probability of a gene being detected above the background level.
When exporting this file from BeadStudio, the user is able to choose which
columns to export.}
\item{Control probe profile ({\tt AsuragenMAQC-controls.txt}) ({\it recommended}) -
text file which contains the summarized data for each of the controls on each array,
which may be useful for diagnostic and calibration purposes.  Refer to the Illumina
documentation for information on what each control measures.}
\item{targets file ({\it optional}) - text file created by the user specifying
which sample is hybridized to each array.
No such file is provided for this dataset, however we can extract sample
annotation information from the column headings in the sample probe profile.}
\end{itemize}


Files with normalized intensities (those with {\tt avg} in the name), as well as files with one
intensity value per gene (files with {\tt gene} in the name) instead of separate intensities
for different probes targeting the same transcript, are also available in this download.  
We recommend users work with the non-normalized probe-specific data in their analysis where possible.  Illumina's background correction step, which subtracts the intensities of the negative control probes from the intensities of the regular probes, should also be avoided.

<<readBeadSummary, eval=FALSE>>=

library(beadarray)
dataFile = "AsuragenMAQC-probe-raw.txt"
qcFile = "AsuragenMAQC-controls.txt"
BSData = readBeadSummaryData(dataFile = dataFile,
qcFile = qcFile, controlID = "ProbeID",
skip = 0, qc.skip = 0, qc.columns = list(exprs = "AVG_Signal",
Detection = "Detection Pval"))

@

The arguments of readBeadSummaryData can be modified to suit data from versions 1, 2 or 3
of BeadStudio. The current default settings should work for version 3 output. Users may need to
change the argument sep, which specifies if the dataFile is comma or tab delimited and the skip
argument which specifies the number of lines of header information at the top of the file. Possible
skip arguments of 0, 7 and 8 have been observed, depending on the version of BeadStudio or way in
which the data was exported. The columns argument is used to specify which column headings to
read from dataFile and store in various matrices. Note that the naming of the columns containing
the standard errors changed between versions of BeadStudio (earlier versions used BEAD STDEV in
place of BEAD STDERR - be sure to check that the columns argument is appropriate for your data).
Equivalent arguments (qc.sep, qc.skip and qc.columns) are used to read the data from qcFile. See
the help page (?readBeadSummaryData) for a complete description of each argument to the function.


\section*{Citing beadarray} 

If you use \Rpackage{beadarray} for the analysis or pre-processing of BeadArray data please cite:

Dunning MJ, Smith ML, Ritchie ME, Tavar\'e S, \textbf{beadarray: R classes and
  methods for Illumina bead-based data}, \emph{Bioinformatics}, \textbf{23}(16):2183-2184

\section{Asking for help on beadarray}

Wherever possible, questions about \Rpackage{beadarray} should be sent to the Bioconductor mailing 
list\footnote{\texttt{http://www.bioconductor.org}}. This way, all problems and solutions will be
kept in a searchable archive. When posting to this mailing list, please first consult the 
\emph{posting guide}. In particular, state the version of \Rpackage{beadarray} and {\tt R} that you 
are using\footnote{This can be done by pasting the output of running the function \texttt{sessionInfo()}.}, 
and try to provide a reproducible example of your problem. This will help us to diagnose the problem. 

<<options, echo=FALSE, eval=TRUE>>=
options(width = 80)
@

This vignette was built with the following versions of R and 
<<sessionInfo>>=
sessionInfo()
@



\end{document}
